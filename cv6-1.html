<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Movable Quadrilateral</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            background-color: #FFFFFF;
        }

        canvas {
            border: 1px solid #ccc;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<button id="saveButton">Save Corners and Draw Grid</button>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const controlPoints = [];
    const pointRadius = 8;
    let draggingPoint = null;

    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 100;  // Adjusted for button space

    function createControlPoint(x, y) {
        return { x, y };
    }

    function drawControlPoints() {
        ctx.fillStyle = 'red';
        controlPoints.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawQuadrilateral() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.beginPath();
        ctx.moveTo(controlPoints[0].x, controlPoints[0].y);
        ctx.lineTo(controlPoints[1].x, controlPoints[1].y);
        ctx.lineTo(controlPoints[2].x, controlPoints[2].y);
        ctx.lineTo(controlPoints[3].x, controlPoints[3].y);
        ctx.closePath();
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 2;
        ctx.stroke();

        drawControlPoints();
    }

    function initializeControlPoints() {
        const margin = 50;
        controlPoints.push(
            createControlPoint(margin, margin),
            createControlPoint(canvas.width - margin, margin),
            createControlPoint(canvas.width - margin, canvas.height - margin),
            createControlPoint(margin, canvas.height - margin)
        );

        drawQuadrilateral();
    }

    function getMousePosition(event) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
    }

    function isPointClicked(point, mousePos) {
        return Math.sqrt((point.x - mousePos.x) ** 2 + (point.y - mousePos.y) ** 2) < pointRadius;
    }

    function handleMouseDown(event) {
        const mousePos = getMousePosition(event);
        for (const point of controlPoints) {
            if (isPointClicked(point, mousePos)) {
                draggingPoint = point;
                break;
            }
        }
    }

    function handleMouseMove(event) {
        if (draggingPoint) {
            const mousePos = getMousePosition(event);
            draggingPoint.x = mousePos.x;
            draggingPoint.y = mousePos.y;
            drawQuadrilateral();
        }
    }

    function handleMouseUp() {
        draggingPoint = null;
    }

    function handleSaveCorners() {
        const corners = controlPoints.map(point => ({ x: point.x, y: point.y }));
        console.log('Saved Corners:', corners);
        alert('Corners saved! Drawing the grid now.');

        drawGridWithinQuadrilateral(corners);
    }

    function drawGridWithinQuadrilateral(corners) {
        const [p0, p1, p2, p3] = corners;

        // Number of divisions for the grid
        const divisions = 10;

        // Calculate step increments
        const xStepTop = (p1.x - p0.x) / divisions;
        const yStepTop = (p1.y - p0.y) / divisions;
        const xStepBottom = (p3.x - p2.x) / divisions;
        const yStepBottom = (p3.y - p2.y) / divisions;
        const xStepLeft = (p2.x - p0.x) / divisions;
        const yStepLeft = (p2.y - p0.y) / divisions;
        const xStepRight = (p3.x - p1.x) / divisions;
        const yStepRight = (p3.y - p1.y) / divisions;

        // Draw vertical lines
        for (let i = 0; i <= divisions; i++) {
            const startX = p0.x + i * xStepTop;
            const startY = p0.y + i * yStepTop;
            const endX = p2.x + i * xStepBottom;
            const endY = p2.y + i * yStepBottom;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = 'gray';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw horizontal lines
        for (let i = 0; i <= divisions; i++) {
            const startX = p0.x + i * xStepLeft;
            const startY = p0.y + i * yStepLeft;
            const endX = p1.x + i * xStepRight;
            const endY = p1.y + i * yStepRight;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = 'gray';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);

    document.getElementById('saveButton').addEventListener('click', handleSaveCorners);

    initializeControlPoints();
</script>

</body>
</html>
